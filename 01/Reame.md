### 웹 역사

---

1993 -> 모자이크 브라우저 <br/>
1994 - 넷스케이프 -> 넷스케이프 내비게이터
넷스케이프 네비게이터에서만 라이브 스크립트 사용가능 했엇음

그때 홍보용으로 자바가 유명하니 자바스크립트로 명시

1995 -> 자바스크립트 -> 넷스케이프 내비게이터를 통해 얄려짐

1996 -> 마이스크로 소프트사 -> jscript를 만듬
익스터넷 익스플로러가 jscript를 장착후 출시
하지만 넷스케이프의 점유율의 미치지 못함

넷스케이프사와 익스플러라 사가 상품 경쟁을 함
이때 넷스케이프사가 ECMA 에 요청을 통해 자바스크립트가 표준으로 명시

1997 ->ECMAScript 1
1998 ->ECMAScript 2
1999 ->ECMAScript 3
2000 ->ECMAScript 4

하지만 인터넷익스플로러가 점유율이 높아지면서 ECMAScript의 표준이 무의미가됨 그이후로 표준상향이 되지않음

넷스케이프가 점유율이 하락하자 모질라의 파이어폭스가 등장(action script 장착)

이때의 개발자들의 고통이 시작 파이어폭스, 인터넷익스플로러,넷스케이프의 브라우저가 다 다름으로 웹표준, 코드,브라우저 호환의 어려움을 겪음

이 문제들로 인해 jqerry의 등장으로 웹 브라우저들의 호환이 쉬워짐

2008 -> Chrome 등장
Chrome에서 자바스크립트 실행시 기존에 10~20배 이상 속도 상향

2009 -> ECMAScript5 등장 웹 3사의 웹 표준의 생성 (9년동안 인터넷익스플로에서 표준을 거부?)

2015 -> ECMAScript6
2016 -> ECMAScript7

2018 -> Vanilla javscript? 유행
jquerry 필요성이 없어지므로 등장

ECMAScript 버젼들의 호환을 위한 Babel의 등장으로 ECMAScript버젼의 상관없이 모든 브라우저에서 호환이 가능해짐

오늘날의 SPA Single page Aplication 의 등장으로 부부적인 웹의 변경이 가능

---

### Next.js는 왜 TailWind Css 를 적용시했을까?

- 대부분의 CSS-in-JS 라이브러리들이 쓰는 방식은 Runtime CSS-in-JS 또는 Runtime stylesheets 라고 한다. 스타일을 정의하는 코드가 클라이언트 런타임 때 실행되는 JS 번들에 포함되는 방식인데 브라우저는 스타일 코드를 해석하지 못하므로 라이브러리의 코드도 JS 번들에 포함되어야 한다. 해석된 스타일 코드는 document의 head 태그에 style 태그를 추가하거나CSSStyleSheet API로 직접 CSSOM에 적용시켜서 사용한다.

      JS 번들 용량 증가: 스타일 코드와 라이브러리 런타임 코드가 클라이언트로 전달되어야 한다.

  페이지 렌더링 시간 증가: JS에 작성된 CSS 코드를 구문 분석하고 동적으로 추가하면서 Scripting 시간 증가
  단점이 있긴 하지만 장점으로 얻는 개발용이성이 워낙 커서 React의 인기와 함께 유행했다고 한다. 그러나 CSR 환경을 바탕으로 두고 구상한 방법이었기 때문에 SSR 환경에서 문제가 나타났다.

  기본적으로 SSR에서 CSS-in-JS 라이브러리를 그대로 사용하면 hydrate 이전 서버에서 받아오는 HTML에 스타일이 전혀 적용되지 않아 잠깐 날 것의 HTML이 나타나는 문제가 있다. 때문에 초기 HTML에 포함되는 요소에 대한 CSS인 Critical CSS를 서버쪽에서 사용할 수 있도록 하는 처리가 필요하다. 보통 SSR 과정에서 정적으로 생성되는 요소의 CSS만 추출해서 HTML에 적용하도록 설정한다.

위 방법도 문제를 완벽히 해결하지는 못한다. Critical CSS에 대한 코드는 클라이언트 쪽에서 실행될 JS에도 포함되어야 한다. 때문에 동일한 스타일에 대한 코드가 초기 HTML에서 한 번, JS 번들에서 두 번 클라이언트에게 전달된다.

---

### Tailwind CSS

Tailwind CSS는 Utility CSS로 class name을 컴포넌트가 아니라 기능에 붙임으로써 CSS의 문제를 해결하려 했다. 예전에 유명했던 Bootstrap과 유사하게 미리 정의된 스타일 구성 요소를 가져와서 사용하는 방식으로 동작한다. 대신 utility CSS이므로 필요에 따라 확장성있게 CSS를 작성할 수 있고, 빌드 시에 사용하지 않는 클래스는 제거되어 번들 크기에 주는 영향도 줄일 수 있다. 또한 atomic한 특성으로 인해 프로젝트의 크기가 거대해져도 스타일시트의 크기가 비례해서 늘어나지 않는 이점도 있다.

SSR 관점에서 중요한 건 런타임에 스타일시트를 생성하지 않고 빌드 타임에 스타일시트를 가져오는 방식이라는 점이다. 때문에 SSR에서도 추가적인 설정 없이 작동할 수 있다.

더 전통적인 방식인 CSS module이나 sass도 똑같이 빌드 타임에 스타일시트를 붙이지만 selector 기반 CSS의 한계를 극복하지 못했기 때문에 tailwind css를 콕 집어서 추천해주고 있는 것 같다.

물론 CSS-in-JS의 장점인 동적 변수를 사용할 수 없고 animation과 transition 사용에 제약이 있어서 완벽히 대체하진 못한다고 한다. 이 이슈들은 inline style이나 CSS module 등 다른 방식과 병행 사용하면서 해결하는 것으로 보인다.

---

### Web API

- liverServer 는 Web Api로써 웹 브라우저에서 자동으로 script 태그를 추가

---

### Async vs Defer

- https://ko.javascript.info/script-async-defer

- HTML에서는 첫 번째줄 부터 차례대로 코드를 읽고 실행함
- script 태그를 만나면 먼저 연결되 javascript 코드를 읽음
  이때 문제는 javascript파일의 초기 다운로드가 오래 걸린다면 사용자에게 화면이 보여지지 않음 그래서 body태그가 끝나기전에 사용했었음
- 다만 이럴경우 만약 jascript파일이 다 다운로드 되기전에 사용자가 jascript 내용이 필요한 버튼이나 상호작용이 필요한 부분을 클릭시 동작되지않고 나중에 동작하게됨 (defer의 동작)

- async 를 붙여서 사용시 jasvascript파일의 다운로드를 병렬처리로써 (비동기처리)하여 html과 javascript 파일 다운로드 동시에 진행 javscript 파일이 다운로드 완료되면 잠시 javascript파일이 실행됨(html파일 다운 멈춤)
  다운로드가 빠르지만 파일의 크기가 크다면 멈춤 현상이 발생할 수 있다

- 이러한 순서의 오류는 먼저 다운로드는 파일이 먼저 실행됨 웹 브라우저에서 동작에 순서가 필요하다면 async를 사용해선 안됨

- async와 defer 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점이 있습니다. 따라서 async와 defer를 적절히 사용하면 사용자가 오래 기다리지 않고 페이지 콘텐츠를 볼 수 있게 할 수 있습니다.
