### 리터럴 표기법이란

- 기본 자료형의 값을 만들어줄 때 사용하는 표기법을 말합니다. 쉽게 말해서 객체로 생성할 수 있는 기본 자료형 값을 간단한 표기법만으로 만들어주는 방식을 의미합니다

- 리터럴표기법이 생성자를 이용한 데이터 표기법보다 더 간단하기 때문에 우리는 리터럴 표기법을 많이 이용합니다.

### 유사배열 객체

- 유사 배열은 배열 메서드를 사용할 수 없다.
- 유사배열 객체는 원본 변경불가
- https://zoon-bloom.tistory.com/37

### 회살표 함수의 this

- 일반함수와 화살표 함수에서의 this의 차이점이 있다.
  - 화살표 함수 안에서 this는 언제나 상위 스코프의 this를 가리키며
  - 이것을 렉시컬 this부릅니다.
- https://zoon-bloom.tistory.com/70

### 생성자 함수

- https://zoon-bloom.tistory.com/82
- 생성자 함수는 객체를 생성하는 함수
- 함수의 매개변수를 활용할 수 있다는 특징
- 생성자 함수는 객체를 생성할 때 new 키워드를 사용하며 이름은 첫글자는 대문자로

### 프로토 타입2

- https://zoon-bloom.tistory.com/43
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성
- 모든 객체의 최상위 객체는 Object.prototype 객체다.
- \_\proto\_\ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다.
- 최상위 객체의 하위 자식 객체들은 '\_\_proto \_\_' 메소드를 부여받는다.
  - 자식 객체 인스턴스에서 \_\_proto\_\_ 메소드를 활용해서 상속한 상위 부모 객체의 정보를 알 수 있다.
    - 하지만 \_\_proto\_\_ 체인 메소드로 함수를 호출하면
      \_\_proto\_\_ 에 바인딩 된 this에는 부모 객체에서 생성한 this바인딩 된 값들이 찾을수없다.
  - ex- childObj.\_\_proto\_\_.getArea() <- 이렇게 사용하면 오류
  - ex- childObj.getArea()

### 프로토타입 체인(prototype chain)

- 프로토타입 체인은 자바스크립트의 객체 지향 프로그래밍 모델의 핵심 개념 중 하나로, 객체 간의 상속을 구현합니다.
- 객체의 속성(메소드 포함)에 접근할 때, 자바스크립트 엔진은 해당 속성을 현재 객체에서 먼저 찾습니다.
- 현재 객체에 해당 속성이 없으면, 엔진은 \_\_proto\_\_를 따라 부모 프로토타입 객체로 이동합니다.
- 이 과정을 반복하여 프로토타입 체인을 따라 상위 객체를 탐색합니다. 최종적으로 null에 도달하면 탐색을 중지합니다.
  - #### 자식 객체 인스턴스에서 부모 객체의 메소드를 호출할 때, 메소드가 현재 객체에 없다면 프로토타입 체인을 통해 부모 객체에서 메소드를 찾습니다.<br/>따라서 \_\_proto\_\_를 명시적으로 사용할 필요가 없습니다.

### 내장 객체는 인스턴스를 사용해서 변경가능할까?

- 정적 성격:
  Math 객체는 수학적 상수와 함수의 집합을 제공하는 정적 객체입니다. 모든 메소드와 속성은 객체 자체에 속하며, 인스턴스와 무관하게 접근할 수 있습니다.
  예: Math.PI, Math.sqrt()
- 단일성 및 효율성:
  수학 함수와 상수는 대부분의 프로그램에서 공통적으로 사용되며, 이를 위해 여러 개의 인스턴스를 생성하는 것은 불필요하고 비효율적입니다.
  Math 객체는 단일 객체로 존재함으로써 메모리 사용을 최적화하고, 동일한 객체를 여러 곳에서 재사용할 수 있습니다.
- 객체의 일관성:
  Math 객체는 변경할 수 없도록 설계되어 있어, 전역적으로 일관된 동작을 보장합니다. 이는 동일한 수학 연산이 항상 동일한 결과를 반환하도록 보장합니다.
  예: Math.PI는 항상 3.141592653589793입니다.
  - 생성자 함수의 부재: Math 객체는 생성자 함수가 아니므로, new Math()와 같은 구문을 사용할 수 없습니다. 이는 자바스크립트 엔진이 객체를 생성하는 방식에 따라 에러를 발생시킵니다.
    시도할 경우, TypeError: Math is not a constructor 에러가 발생합니다.
    - #### Math 객체는 수학적 함수와 상수를 제공하는 정적 객체로, 인스턴스를 생성할 수 없도록 설계되어 있습니다. 이는 객체의 효율성과 일관성을 보장하고, 전역적으로 동일한 동작을 유지하기 위한 것입니다. 이러한 설계는 자바스크립트의 언어적 특성과 목적에 맞추어진 것입니다.

### 래퍼객체

- const num1 = 10;
- const num2 = new Number(10);
- console.log(num1 instanceof Number); //false
- console.log(num2 instanceof Number); // true
- Number라는 숫자형태에 상위 부모객체가 있는데
  10이라고 선언한 변수는 Number 의 인스턴스가 아니라고 나온다!
- 그럼에도 num1.toFixed와 같은 메소드를 사용할 수 있는 이유는 자바스크립트 엔진이 자동적으로 Number의 인스턴스로 변경시켜주기때문?

### 클래스 문법

- \# 키워드를 통해 private 비공개 속성을 만들 수 있음
- 클래스는 class 키워드를 사용해서 선언한다.
- 클래스는 내부에 constructor 메소드를 가지고 있다.
- 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.
- 즉 클래스는 let, const 변수처럼 호이스팅이 발생.
- extend 상속

  - 상속을 하든, 상속을 안하든 반드시
  - constructor 를 가지고 있어야한다.
  - extends를 사용해서 상속을 구현하면
  - 상속 받은 자식 클래스는 super() 를 사용해야한다.
  - 자신이 상속한 클래스를 호출하는 역할
  - 자식에서는 부모에서 선언되어있는 속성들을 super메서드의 인자로 전달해야한다.
  - 생성자 함수로서 호출할 수 있는 함수는 함수 객체가 생성되는 시점에 프로토타입도 더불어 생성.

- ## get, set

  - set 통해 class의 값을 지정할 수 있음
  - set은 인스턴스가 생성될때 자동으로 호출되어 consturctor 변수명의 이름과 같다면 값이 설정됨?
  - set speed 는 constructor 의 명시되어 있는 this.speed에 의해 이름이 호출되는 것?
  - 이때 constructor 와 set 메소드의 이름이 같으면 무한루프 오류가 발생
  - 이것을 해결하기 위해 이름앞에 \_ 언더바를 붙이는것이 관례! (get 또한 동일)
  - class Car {
    constructor(speed) {
    this.speed = speed;
    }

    - // 무한루프에 빠진 오류 발생
    - // \_속성명을 붙여서 무한루프에 빠지지않게함
    - // get 또한 \_speed로 작성
    - set speed(value) {
      if (value < 0) {
      throw new Error("speed must be bigger than 0");
      }
      this.\_speed = value;
      }
      - getSpeed() {
        return this.\_speed;
        }
        }

### statid 키워드, 정적 메서드와 프로토타입 메서드의 차이

- static 키워드를 class 내에서 메소드에 앞에 붙여 인스턴스를 방지화
- 부모생성자 함수를 사용해서만 static 키워드의 접근 가능
- 정적 메서드와 프로토타입 메서드는 프로토타입 체인이 다르다.
- 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출.
- 정적 메서드는 인스턴스 프로퍼티 참조 불가능. 프로토타입 메서드는 가능.

### 오버라이딩 vs 오버로딩

- #### 오버라이딩(overriding)
  상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식
  ㅤ
- #### 오버로딩(overloading)
  함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.

### 비파괴적 , 파괴적

- https://zoon-bloom.tistory.com/15

### 클로저

- https://zoon-bloom.tistory.com/138
- 중첩함수 상황에서 내부함수에 정의되어 있지 않은 변수나 값을 참조할려고하였을때 실행컨텍스트를 통해 상위 렉시컬 스코프로 들어가서 레코드를 참조하여 해당 값 또는 변수를 찾고 해당 값이 존재한다면 참조하여 값을 사용한다 이때 클로저 현상이 발생한다. 해당 메모리 값은 사라지지 않고 그대로 남아있는다.
