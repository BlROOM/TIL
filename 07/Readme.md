## 리액트의 이벤트 관찰 diffing, batch update

- const [count, setCount] = useState(0);
- const onClickHandler = () => {
  setCount((prevCount) => {
  prevCount
  })
  };
- useState를 통해 콜백함수로 prev라는 값을 가져올 수 있다. 콜백 함수로 호출하게되면 항상 최신에 상태값을 가지고 있는다.
- setCount(100); 이방식은 한번에 새로운 값을 할당하는 방법
- 이전 값을 참조한다면 콜백함수를 사용하여 prev값에 접근하고
- 이전 값을 참조하지 않는다면 setCount(100) 같이 호출

  ## 상태 업데이트와 비동기성

  React의 상태 업데이트는 비동기적으로 일어납니다. 이는 성능 최적화를 위해 React가 여러 상태 업데이트를 일괄 처리(batch processing)하기 때문입니다. 이로 인해, 동일한 렌더링 사이클 내에서 여러 번의 상태 업데이트가 일어날 경우, 각 상태 업데이트가 이전 상태 값을 올바르게 반영하지 못할 수 있습니다.

### 리액트가 렌더링되는 조건

- #### 1 상태(State)의 변경

  컴포넌트의 상태가 변경되면 React는 해당 컴포넌트를 다시 렌더링합니다. 상태는 useState 훅을 사용하여 관리할 수 있으며, setState 함수를 호출하여 상태를 업데이트합니다. 상태가 변경되면 React는 컴포넌트를 다시 렌더링합니다

- #### 2. 속성(Props)의 변경

  부모 컴포넌트에서 전달된 속성이 변경되면 자식 컴포넌트가 다시 렌더링됩니다. 이는 부모 컴포넌트가 다시 렌더링될 때 자식 컴포넌트로 전달되는 속성이 변경되면 자식 컴포넌트도 다시 렌더링된다는 의미입니다.

- #### 3. 부모 컴포넌트의 렌더링

  부모 컴포넌트가 다시 렌더링되면, 자식 컴포넌트도 다시 렌더링됩니다. 이는 부모 컴포넌트가 상태나 속성의 변경으로 인해 다시 렌더링될 때 자식 컴포넌트도 다시 렌더링된다는 의미입니다.

- #### 4. 컨텍스트(Context)의 변경

  React 컨텍스트(Context)를 사용하여 컴포넌트 트리 전체에서 데이터를 공유할 수 있습니다. 컨텍스트 값이 변경되면 해당 컨텍스트를 사용하는 모든 컴포넌트가 다시 렌더링됩니다.

- #### 5. 강제 업데이트

  React에서는 forceUpdate 메서드를 사용하여 컴포넌트를 강제로 다시 렌더링할 수 있습니다. 이는 보통 권장되지 않지만, 클래스 컴포넌트에서 사용할 수 있습니다.

- #### 6. 키(Key) 변경
  리스트 렌더링 시, React는 각 항목에 고유한 키를 사용하여 항목을 추적합니다. 키가 변경되면 해당 항목이 다시 렌더링됩니다.

### React.memo

- 컴포넌트의 상태를 메모, 기억하는 것
- 부모 컴포넌트에서 관리하는 상태값이 변해서 생기는 자식 컴포넌트의 재렌더링 현상을 자식 컴포넌트에 memo를사용해서 방지한다.

### useCallback

- const [user, setUser] = useState(userInialized);
- const onChangeHandler = useCallback(
  (text: string) => {
  const filterUser = user.filter(item => item.includes(text));
  setUser(filterUser);
  },
  [user]
  );
- 함수를 최적화할때 메모이제이션 기법을 활용해서 deps, 의존성 배열에 함수에서 의존하는 값을 넣어주어 함수가 재렌더링을 방지할 수 있다.
  - ### usecallback 의존성 배열안에 usecallback 함수를 또 넣어버리면?
  - React에서 useCallback을 사용할 때 의존성 배열에 useCallback을 사용한 함수를 추가하는 것은 권장되지 않습니다. 의존성 배열에 useCallback을 사용한 함수를 추가하면 무한 루프가 발생할 수 있습니다.
  - useCallback은 함수를 메모이제이션하는 훅이며, 의존성 배열을 통해 해당 함수가 의존하는 값들을 지정합니다. useCallback 안에서 다른 useCallback을 호출하면 그 함수가 변경될 때마다 새로운 함수 인스턴스가 생성됩니다. 이는 의존성 배열에 해당 함수를 추가할 때 무한 루프로 이어질 수 있습니다.

### useMemo 메모이제이션

- 많은 연산,작업이 들어간 값을 메모이제이션, 즉 계산을 방지할 때 사용한다.
- 의존성배열에 어떠한 값이 변경될 때 해당 연산을 실행시킬 값을 넣어준다.
