### GET메소드가 보안에 취약한 이유?

- URL에 노출되는 데이터:
  GET 요청은 데이터를 URL의 쿼리 파라미터로 포함하여 전송합니다. 예를 들어, http://example.com/page?username=alice&password=secret 같은 형태입니다. 이로 인해 민감한 데이터가 URL에 포함되어 쉽게 노출될 수 있습니다.

- 브라우저 히스토리와 캐싱:
  브라우저는 방문한 URL을 히스토리에 저장합니다. 따라서, GET 요청에 포함된 민감한 데이터도 브라우저 히스토리에 남게 됩니다.
  또한, GET 요청은 캐시될 수 있습니다. 이는 민감한 데이터가 캐시된 후 다른 사람에게 노출될 수 있는 위험을 증가시킵니다.
- 로그 파일에 기록:
  서버 로그 파일에도 요청한 URL이 기록됩니다. 따라서 GET 요청으로 전달된 민감한 정보는 서버 로그 파일에 남아 보안 위험을 초래할 수 있습니다.
- 제한된 데이터 길이:
  GET 요청의 URL 길이에는 제한이 있습니다. 이는 대용량 데이터를 GET 요청으로 전송하는 데 부적합하게 만들고, 데이터 손실이나 예기치 않은 동작을 초래할 수 있습니다.

### 헤킹 또는 탈취방법?

- 인젝션 공격은 웹 애플리케이션에 악의적인 코드나 쿼리를 삽입하여 시스템을 공격하는 방법입니다. 가장 일반적인 유형은 SQL 인젝션(SQL Injection)이지만, 다른 형태의 인젝션도 존재합니다.

- SQL 인젝션 (SQL Injection)

  - SQL 인젝션은 웹 애플리케이션이 사용자 입력을 제대로 검증하지 않고 직접 SQL 쿼리에 포함할 때 발생합니다. 공격자는 SQL 쿼리에 악의적인 코드를 삽입하여 데이터베이스를 조작할 수 있습니다.

  - 데이터베이스 탐색:
    - 공격자는 SQL 인젝션을 통해 데이터베이스 구조를 파악할 수 있습니다.
      예시: ' OR '1'='1를 입력하여 로그인 우회
      데이터 추출: 공격자는 SELECT 쿼리를 조작하여 민감한 데이터를 추출할 수 있습니다.
      예시: '; SELECT \* FROM users;--와 같은 쿼리를 삽입하여 모든 사용자 데이터를 탈취

- 크로스 사이트 스크립팅 (XSS)

  - XSS는 공격자가 악의적인 스크립트를 웹 페이지에 삽입하여 다른 사용자의 브라우저에서 실행되도록 하는 공격입니다. 주로 클라이언트 측에서 발생합니다.

- 명령어 인젝션 (Command Injection)

  - 명령어 인젝션은 웹 애플리케이션이 사용자 입력을 운영 체제 명령어로 실행할 때 발생합니다. 공격자는 악의적인 명령어를 삽입하여 서버에서 임의의 명령을 실행할 수 있습니다.

- LDAP 인젝션 (LDAP Injection)
  - LDAP 인젝션은 사용자 입력을 LDAP 쿼리에 삽입하여 디렉터리 서비스에 대한 공격을 수행하는 것입니다.

### Json stringfy 쓰는이유

- app.use(bodyParser.json());
- json 형식으로 데이터를 사용하겠다는내용으로 설정되어있기때문에
- 프론트에서 fetch, 또는 비동기 방식 api 값을
- 데이터 직렬화: JavaScript 객체를 JSON 문자열로 변환합니다.데이터를 전송하기 전에 객체를 텍스트 형식으로 변환하는 과정입니다.
  서버는 이 문자열을 받아서 다시 객체로 변환(JSON.parse)하여 데이터를 처리합니다.
- API 규격 준수:
  대부분의 RESTful API는 클라이언트가 데이터를 JSON 형식으로 전송하기를 기대합니다. 이는 데이터를 구조화하고 표준화된 형식으로 교환할 수 있게 합니다.
- 서버와의 호환성:JSON은 언어와 플랫폼에 독립적인 데이터 형식입니다. 다양한 프로그래밍 언어와 서버 환경에서 JSON을 쉽게 파싱하고 생성할 수 있습니다. 클라이언트(브라우저)와 서버(백엔드) 간의 호환성을 보장합니다.

### HTTP메소드에서 body

- post에서만 body가 존재한다. param값을 이용해서 데이터를 변경해야 하기때문
- GET, HEAD, OPTIONS, TRACE, DELETE (일반적인 경우):
  - 요청에 body를 포함하지 않음. 이들 메소드는 주로 서버에서 데이터를 가져오거나, 메타정보를 확인하거나, 리소스를 삭제하는 데 사용되며, 필요한 정보는 URL에 포함됩니다.
    POST, PUT, PATCH: 요청에 body를 포함함. 이들 메소드는 서버로 데이터를 전송하거나, 리소스를 생성/수정하는 데 사용되며, 전송할 데이터는 body에 포함됩니다

### API 결과 확인

- const awaitDataAdd = async () => {
  const response = await fetch("http://localhost:4000/todos", {
  method: "POST",
  headers: {
  "Content-type": "applictaion/json",
  },
  body: JSON.stringify({ text: "learn React" }),
  });
  if (response.ok) {
  alert("데이터가 추가됨!");
  }
  };

- response.ok 값을 가지고 해당 메소드 요청의 결과가 실패했는지 성공했는지 알 수 있음

### axios vs fetch

- Fetch API는 ECMAScript 6(ES2015)에서 도입되었습니다. 이전에는 XMLHttpRequest(XHR) 객체를 사용하여 AJAX 요청을 처리했지만, Fetch API는 더 간단하고 강력한 기능을 제공하여 네트워크 요청을 처리할 수 있습니다.
- Axios는 2014년에 릴리스되었습니다. Axios는 HTTP 클라이언트 라이브러리로, 비동기 방식으로 HTTP 요청을 처리하는 데 사용됩니다. 브라우저와 Node.js에서 모두 사용할 수 있으며, 간단하고 직관적인 API를 제공하여 널리 사용되고 있습니다. Axios는 Promise 기반의 API를 제공하여 비동기적으로 데이터를 가져오고 처리하는 데 편리하게 사용할 수 있습니다.
- 둘다 http request 만드는 것은 똑같음
- axios는 라이브러리이고 fetch는 웹에 내장된 메소드(Web api)이기 때문에 axios는 더 넓은 범위에서 사용가능하다(인터넷 익스플로러와 같은)
