### axios 인스턴스 만들기

- https://stack94.tistory.com/entry/TypeScript-Axios-TypeScript-%EC%A0%81%EC%9A%A9%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90#google_vignette
- const axiosInstance = axios.create({
  baseURL: "http://localhost:4000/todos",
  headers: {
  "Content-Type": "application/json",
  },
  });

- // 공통된 에러 처리 함수
  const handleError = (error: any) => {
  console.log(error);
  throw error;
  };

- // 할 일 가져오기
  export const axiosGetTodo = async () => {
  return await axiosRequest("get", "/");
  };

- // 할 일 추가
  export const axiosAddTodo = async (payload: string) => {
  return await axiosRequest("post", "/", { text: payload });
  };

### library vs framework

- 리액트 같은 라이브러리는 개발자가 직접 추가하여 react-router-dom 과 같은 서브 파트 라이브러리리가 필요하다.

- 넥스트.js 와 같은 프레임워크는 자체적으로 route 시스템 등이 내장되어있기때문에 그 규칙을 따라야한다.

### 프롬프트 명령어

- rm -rf[폴더명 or 파일명] - 폴더 삭제명령어
- rem -rf ./\* 현재 폴더의 하위 폴더 및 파일 삭제

- mkdir[폴더명] - 폴더 생성
- cp -rf [폴더명] [복사할 폴더명]
- cp -rf nextjs nextjs-copy => nextjs 폴더를 next-copy 폴더로 복사해라

### Next

- app 폴더 하위에 layout.tsx, page.tsx애플리케이션의 전체적인 구조를 담당
- next의 시작은 index라는 이름을 가지는 파일의 이름이 필요하며
- 폴더의 구조는 pages 또는 app 이라는 이름을 가지는 폴더안에 컴포넌트가 존재해야 한다.
- 만약 두개의 파일이 존재하여 같은 이름의 component가 존재한다면 충돌이 발생한다.
- next는 폴더 구조, 폴더이름으로 라우팅을 하며, 폴더안에 파일이름은 page.jsx, page.tsx 로 고정한다.
- 폴더이름은 케밥케이스로 짓는다. 예시 : todo-master
  - ### 포괄적경로
  - [...slug] <= 와 같이 사용
  - 이렇게 사용하면 안에 무슨 경로가 오던 일괄적으로 해당 파일 밑에 있는 Page.tsx가 다 받아줌
  - ### 중첩경로
  - 폴더구조를 blog/read/new 로 설정하였다면 url에 blog/read/new에서 해당 페이지를 확인할 수 있고 blog폴더와 read 폴더안에도 page.tsx파일이 존재해야함!
  - ### 동적경로
  - 동적으로 url변경되어야하는(상품페이지 같은) 폴더구조에 [id] 와 같은 형태로 폴더를 생성한다.
  - 그 이후 page.tsx를 안에 넣어준후
  - blog/[id] => blog/1 , blog/2 페이지로 이동하면 해당 page.tsx가 렌더링된다.
  - ### 제한경로, private경로 \_폴더이름
  - \_(언더바) 경로를 통해 url, route에 처리되지않도록 파일 설정이 가능하다.
  - ### 그룹경로
  - (폴덩이름) 특정 폴더를 그룹화해서 만들고싶을 때 사용 route에 영향을 받지않는다.(components)
  - ### not-found.tsx
  - src/app 경로에 not-found.tsx를 만들어서 경로에 지정되어있지않는 컴포넌트 처리를 할 수 있다.
    - ### [...slug]를 활용한 not-found 처리
    - 폴더 경로안에서의 not-found tsx 파일은 적용되지않는다.
    - 이때 [...slug] 폴더를 하위경로에 추가해서 not-found.tsx 를 처리할 수 있다.(편법?)
- ### nfce 코드스니펫 설정
- 커맨드+쉬프트+p, typescriptreact.json파일에서 설정
- "Next Function Component": {
  "prefix": "nfce",
  "body": [
  "export default function ${1:$TM_FILENAME_BASE} (){",
  " return (",
  " <>",
  " <h1>${1:$TM_FILENAME_BASE} Component</h1>",
  " </>",
  " );",
  "}",
  ],
  "description": "Create an Next function component"
  },

### 라우팅

- 라우팅은 웹 애플리케이션에서 사용자가 URL을 통해 다른 페이지로 이동하는 것을 의미합니다.
- 사용자가 애플리케이션 내에서 다른 경로로 이동할 때, 해당 경로에 대한 새로운 콘텐츠가 표시됩니다.
- 예를 들어서 사용자가 ‘/about’으로 이동하면, “About US” 페이지가 표시됩니다.

## 라우터(Router)

- 라우터는 이러한 라우팅을 관리하고 처리하는 기능을 제공합니다.
- Next.js에서는 내장된 라우팅 시스템을 사용하여 페이지 간의 이동을 처리합니다.
- 일반적으로 라우터는 사용자의 URL을 해석하고 해당 URL에 맞는 컴포넌트를 렌더링합니다.

## 라우트(Route)

- 라우트는 URL과 특정 컴포넌트 간의 매핑을 나타냅니다.
- 예를 들어, `/about` 경로에 대한 라우트는 "About Us" 페이지 컴포넌트와 연결됩니다.
- 라우트는 일반적으로 페이지의 경로와 해당 경로에 표시할 컴포넌트를 정의하는데 사용됩니다.

### layout.tsx

- root경로에잇는 layout은 제일 끝에 잇는 경로로써 어떠한 페이지에서나 다 렌더링되게된다.
- 그렇기때문에 root에 있는 layout은 건들지 않고 보통은 경로폴더 안에서 layout을 사용한다.

### next.js metadata

- layout.tsx에서는 metadata를 설정할 수 있는데 export const metadata = {
  title: {
  template: "%s | junyoung",
  default: "Nextjs | sucoding",
  },

  description: "First js Generated by Next.js",
  }; 다음과 같이 설정하면 template 값의 이름으로 페이지 이름을 설정 할 수 있다.

### next에서 쿼리스트링값 가져오기

- 'use client'에서 usePathname을 통해 url경로를 가져올 수 있음(폴더경로주소만)
- 쿼리스트링을 가져오는방법 'use client' 에서 useSearchParams 훅을 사용
- 서버 컴포넌트에섣params라는 인자를 받아 타입설정후 searchParams 값을 객체구조분해해서 받아옴
- 만약 동적 라우트를 통해 [] 대괄호로 폴더를 설정했다면 폴더이름의 들어간 이름을 통해 params로 받을 수 있다.
- // "use client";
  // import { useSearchParams } from "next/navigation";

- type BlogPage = {
  params: {};
  searchParams: {
  lang: string;
  page: string;
  };
  };

- export default function BlogPage(params: BlogPage) {
// const params = useSearchParams();
// console.log(params.get("lang"), "params");
// console.log(params.get("page"), "params");
const { searchParams } = params;
console.log(searchParams, "params");
return (
<>
<h1>Blog Detail page Component</h1>
</>
);
}

### next.js에 서버 컴포넌트와 클라이언트 컴포넌트

- 서버 컴포넌트 - 화면에 보이기전에 실행되는 컴포넌트
- 클라이언트 컴포넌트 = 화면에 보인 후 실행되는 컴포넌트

- ssr방식은 서버에서 사용자에게 보여지는 파일을 미리 만들어서 클라이언트에게 보내짐

- 'use client'로 지정된 컴포넌트는 클라이언트 사이드 렌더링으로 동작하긴하지만
  그렇다고 <strong>서버 컴포넌트 렌더링을 거치지 않는건 아니다!!</strong>
  초기 최초 렌더링시에는 서버 컴포넌트로 인식하기 때문?

## Hydration

- next에서는 두번의 렌더링을 통해 페이지가 보여지게 되는데 초기 한번의 렌더링은 정적 html파일을 클라이언트에게 보내 css와 html파일의(documnet 타입) 정적인 부분을 먼저 보여지게된다.(inital load)

- 두번째로 클라이언트 측에서 자바스크립트 파일 Chunk 단위로 다운로드를 하여 DOM 요소에 렌더링하게 된다 이부분을 <strong>hydrate</strong>라고 부른다!

### routing, 라우팅

- Link 라는 태그를 사용해서 -next/Link 페이지에서 라우팅 다른 페이지로 이동을 할 수 있다.
- 'use client' 에서 useRouter훅을 가져와서 router/navigation back(뒤로가기), push(이동시키기), replace(히스토리 저장시키지 않고 이동) refresh(새로 고침) 등을 사용할 수 있다.
- push는 현재 위치한 url을 히스토리에 저장시킨 후 페이지 이동 (사용자가 나중에 뒤로가기나 앞으로가기등에 사용할 히스토리)
- replace는 현재 위치한 url을 히스토리에 저장시키지 않는다. (결제 페이지나, 장바구니, 마이페이지등) 히스토리 정보를 남기면 안되는 페이지에 사용
- 만약 세션이 종료된 사용자(로그아웃)가 권한이 필요한 페이지로 이동할려고한다면 redirect를 사용해서 사용자가 접근조차, 해당 페이지가 있다는 것을 모르게 하는 것이 좋다.
- #### prefetch 라우팅 메소드는 빠르게 미리 로드하여 탐색 기능을 사용할 수 있다! 하지만 배포 환경에서만 확인이 가능하다!

### 폰트 최적화

- import { Roboto } from "next/font/google";

const roboto = Roboto({ weight: ["400", "700"], subsets: ["latin"] });

-       <h2 className={roboto.className}>root footer</h2>
- 해당 방식처럼 사용하면 최적화된 폰트사용가능
- 해당 폰트는 next에 서버사이드 렌더링으로 돌아가기때문에 빠르고 캐싱처리되어 사용가능
- goole fonts에서 import해서 사용하면 깜빡임 현상이 발생
