### next.js layout에서의 metadata

- 페이지의 제목또는 설명을 next.js에서는 layout안에 metadata를 사용해서 설정가능하다

- export const generateMetadata = async () => {
  const title = new Promise(resolve =>
  setTimeout(() => {
  resolve("Async title");
  }, 2000)
  );
  return { title };
  };
- 위와 같이 비동기 함수로 상품 디테일 페이지의 정보를 제목을띄우기위해 비동기적으로 metadat도 설정 가능하다.

-export const metadata = {
title: {
template: "%s | Junyoung",
default: "Nextjs | Sucoding",
},

description: "First js Generated by Next.js",
};

- template에서 제목은 default의 제목보다 나중 경로들의 컴포넌트에서 쓰이게 된다 현재 폴더 경로와 같은 주소에 있다면 defualt 제목이, 아니라면 default에 제목이 출력됨!

### 에릭 마이어의 리셋.css

- 예전에는 기본 설정되어있는 css설정을 지우고자 reset.css파일이 필요했었다.
- 그중에서 많이 사용되는 에릭 마이어의 리셋 파일을 많이 사용함

### Next에서의 Link태그

- next에서 link태그를 사용시에는 이점은 a태그로 인식되어 seo 최적화에 좋다

### Next에서의 client컴포넌트와 server컴포넌트

- Next프로젝트에서 작업시에 컴포넌트는 가능한 server컴포넌트로 만드는것이 권장사항이다
- client컴포넌트는 가능한 돔 트리에서 최하단의 위치하도록 구성해야하며
- client컴포넌트가 상단에있다면 그 밑에 있는 컴포넌트는 모두 다 client컴포넌트로 변하게된다.

- server컴포넌트에서 지연이 걸리는 비동기적인 코드가 있다면 그 컴포넌트를 이용하는 전체 컴포넌트가 지연이 걸리는 현상이 발생
- 만약 여러 컴포넌트가 여러 지연현상이 발생한다면 제일 오래걸리는 지연 컴포넌트를 기준으로 렌더링된다. 즉 모든 지연이 완료될때 까지 컴포넌트가 렌더링되지않는다.

- 이때 next에서는 지연을 위한 loading.tsx 컴포넌트를 통해 loading관련 컴포넌트를 설정할 수 있다.

### Next 스트리밍

- 페이지를 끊기지않게 보여주기 위한 기능
- 지연시 현재 경로와 가장인접한 loading.tsx 컴포넌트가 보여지게 된다.
- loading.tsx 파일을 만들어서 지연이 걸리는 부분은 loading.tsx 파일이 보여지게끔 설정이 가능하며 해당 파일은 모든지연은 끝나면 사라진다.
- ### loading spinner
- react-icons에서 spin 아이콘을 가져오고
- tailwind css 에서 classname 에 animate-spin 을 작성
- import { AiOutlineLoading3Quarters } from "react-icons/ai";

export default function loading() {
return (
<>
<AiOutlineLoading3Quarters className="animate-spin" />

<h1>loading Component</h1>
</>
);
}

### React의 Suspense 기능, Razy 기능

- lazy로딩 사용법 <= react 18버젼 사용법
- 컴포넌트가 처음 렌더링 될 때 ServerOne을 포함한 번들을 자동으로 불러옵니다.
  React.lazy는 동적 import()를 호출하는 함수를 인자로 가집니다. 이 함수는 React 컴포넌트를 default export로 가진 모듈 객체가 이행되는 Promise를 반환해야 합니다.
- 보통 Suspense와 같이 사용되며 lazy로딩을 사용해 import한 컴포넌트를 suspense로 감싸주어 사용한다.
- const ServerOneComponent = React.lazy(() => import("@/components/ServerOne"));
- export default function page() {
  console.log(ServerOneComponent, "ServerOneComponent");
  return (
  <>

<h1>page Component</h1>
<Suspense fallback={<h1 className="text-red-900">loading....</h1>}>
    <Suspense fallback={<Loading />}>
    <ServerOneComponent />
    </Suspense>

- <Suspense fallback={<h1 className="text-red-900">loading....</h1>}>
  <ServerOne />
  </Suspense>
  <Suspense fallback={<h1 className="text-green-900">loading....</h1>}>
  <ServerTwo />
  </Suspense>
- Suspense감싼 컴포넌트 즉 비동기작업, 지연이 걸리는 컴포넌를 Suspense로 감싸서 fallback 옵션에 로딩때 보여줄 컴포넌트를 보여줄 수 있다.
- React에서 Suspense 컴포넌트의 fallback 옵션에 "use client"가 지정된 컴포넌트를 사용해도 문제가 발생하지 않는다. Suspense 컴포넌트의 fallback 옵션은 로딩 상태에서 보여줄 컴포넌트를 지정하는 것이며, 이 컴포넌트가 클라이언트 측에서 실행되도록 구성하는 것은 정상적인 사용 사례 중 하나입니다.
- next에서 지원하는 loading.tsx와의 차이점은 Suspens로 감싼 부분은 컴포넌트 개별적, 일부분 스트리밍 처리를 할 수 있고
  loading.tsx는 페이지 전체를 스트리밍 처리 할 수있다.
  - 다만 loading.tsx는 조금 느리게 보여지는 부분이 있다는 애기가 있다?

### Next, error.tsx 에러 컴포넌트

- 폴더 경로에 error를 처리하기위한 컴포넌트를 커스터마이징할수잇다. 폴더 밑에 error.tsx를 추가
- error.tsx는 use client 속성을 붙여줘야한다!
- error페이지는 error 객체를 전달받음 erorr.message로 에러에 대한 메세지를 전달받을 수 있음
- error 컴포넌트는 경로에 중첩하여 사용할 수 있다.
- 컴포넌트 렌더링된 경로에 error 발생시 경로에 가장 가까운 error.tsx가 렌더링된다.
- reset이란 함수도 받을 수있음
- 해당함수는 에러가 난 컴포넌트 이전 컴포넌트를 불러오려는 시도
- 하지만 조건으로써 에러가 난 컴포넌트가 use client 컴포넌트여야 함!

### 클라이언트에서 api패칭과 서버에서 api 패칭

- 클라이언트 컴포넌트
  - "use client";

import { useEffect, useState } from "react";

export default function Client() {
const [loading, setLoading] = useState(false);
const [posts, setPosts] = useState([]);
const getPosts = async () => {
setLoading(true);
try {
const result = await fetch("https://jsonplaceholder.typicode.com/posts");
const data = await result.json();
setPosts(data);
setLoading(false);
} catch (error) {
console.log(error, "error");
setLoading(false);
}
};
// https://jsonplaceholder.typicode.com/posts

useEffect(() => {
getPosts();
}, []);

return (

- <>client Component</>
  {loading ? "Loading..." : <>{JSON.stringify(posts)}</>}
  </>
  );
  }

---

- 서버 컴포넌트

- export default async function Server() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");

  const data = await res.json();
  console.log(data);
  return (
  <>
  <>Server Component</>
  <>{JSON.stringify(data, null, 2)}</>
  </>
  );
  }

  - 클라이언트에서는 useEffect를 사용해서 api 를 호출하며 초기에 데이터가 없는 상태도 렌더링하게 된다. 새로 고침시 깜빡임 현상
  - 하지만 서버컴포넌트 컴포넌트 함수 자체에 async와 await을 사용해서 fet함수를 호출하는 것만으로도 데이터를 패팅할 수 있다.
    또한 리액트 초기 렌더링시에 데이터값이 세팅되지 않았을때의 깜빡임 현상도 일어나지 않는다.
  - 리액트에서 useEFfectf라는 함수와 여러 상황에 맞게 api함수를 호출한다는거 자체가 오류일 수 있음!
  - 리액트에서는 react-query 와 같은 서브파티 라이브러리가 필요하다.
  - Next에서는 캐싱, 메모이제이션등 이미 server 컴포넌트에서 설정되어있기 때문에 따로 플러그인이나 라이브러리가 필요하지않다.
